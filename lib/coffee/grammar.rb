# Autogenerated from a Treetop grammar. Edits may be lost.


module Coffee
  include Treetop::Runtime

  def root
    @root || :code
  end

  module Code0
    def statement
      elements[2]
    end

  end

  module Code1
    def statement
      elements[1]
    end

    def more_statements
      elements[3]
    end

  end

  module Code2
    def value
      [statement] + more_statements.elements.map {|s| s.statement }
    end
  end

  def _nt_code
    start_index = index
    if node_cache[:'Coffee#code'].has_key?(index)
      cached = node_cache[:'Coffee#code'][index]
      if cached.kind_of? LeftRecursion
        cached.found(@stack.involved_recursions(cached))
        return nil
      end
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end
    lrec = @stack.push(:'Coffee#code')
    node_cache[:'Coffee#code'][index] = lrec

    r0 = nil
    loop do
      i0, s0 = index, []
      s1, i1 = [], index
      loop do
        r2 = _nt_space
        if r2
          s1 << r2
        else
          break
        end
      end
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      s0 << r1
      if r1
        r3 = _nt_statement
        s0 << r3
        if r3
          s4, i4 = [], index
          loop do
            r5 = _nt_space
            if r5
              s4 << r5
            else
              break
            end
          end
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          s0 << r4
          if r4
            s6, i6 = [], index
            loop do
              i7, s7 = index, []
              i8 = index
              if has_terminal?(';', false, index)
                r9 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure(';')
                r9 = nil
              end
              if r9
                r8 = r9
              else
                r10 = _nt_newline
                if r10
                  r8 = r10
                else
                  @index = i8
                  r8 = nil
                end
              end
              s7 << r8
              if r8
                s11, i11 = [], index
                loop do
                  r12 = _nt_space
                  if r12
                    s11 << r12
                  else
                    break
                  end
                end
                r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
                s7 << r11
                if r11
                  r13 = _nt_statement
                  s7 << r13
                  if r13
                    s14, i14 = [], index
                    loop do
                      r15 = _nt_space
                      if r15
                        s14 << r15
                      else
                        break
                      end
                    end
                    r14 = instantiate_node(SyntaxNode,input, i14...index, s14)
                    s7 << r14
                  end
                end
              end
              if s7.last
                r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                r7.extend(Code0)
              else
                @index = i7
                r7 = nil
              end
              if r7
                s6 << r7
              else
                break
              end
            end
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            s0 << r6
            if r6
              s16, i16 = [], index
              loop do
                r17 = _nt_newline
                if r17
                  s16 << r17
                else
                  break
                end
              end
              r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
              s0 << r16
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(Code,input, i0...index, s0)
        r0.extend(Code1)
        r0.extend(Code2)
      else
        @index = i0
        r0 = nil
      end

      if lrec.active?
        r0 = left_recursion_update(lrec, start_index, r0)
      else
        node_cache[:'Coffee#code'][start_index] = r0
      end
      break unless lrec.active?
    end
    @stack.pop

    r0
  end

  module Statement0
    def id
      elements[0]
    end

    def expression
      elements[4]
    end
  end

  def _nt_statement
    start_index = index
    if node_cache[:'Coffee#statement'].has_key?(index)
      cached = node_cache[:'Coffee#statement'][index]
      if cached.kind_of? LeftRecursion
        cached.found(@stack.involved_recursions(cached))
        return nil
      end
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end
    lrec = @stack.push(:'Coffee#statement')
    node_cache[:'Coffee#statement'][index] = lrec

    r0 = nil
    loop do
      i0 = index
      r1 = _nt_builtins
      if r1
        r0 = r1
      else
        i2, s2 = index, []
        r3 = _nt_identifier
        s2 << r3
        if r3
          s4, i4 = [], index
          loop do
            r5 = _nt_space
            if r5
              s4 << r5
            else
              break
            end
          end
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          s2 << r4
          if r4
            if has_terminal?('=', false, index)
              r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('=')
              r6 = nil
            end
            s2 << r6
            if r6
              s7, i7 = [], index
              loop do
                r8 = _nt_space
                if r8
                  s7 << r8
                else
                  break
                end
              end
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              s2 << r7
              if r7
                r9 = _nt_expression
                s2 << r9
              end
            end
          end
        end
        if s2.last
          r2 = instantiate_node(Assign,input, i2...index, s2)
          r2.extend(Statement0)
        else
          @index = i2
          r2 = nil
        end
        if r2
          r0 = r2
        else
          r10 = _nt_expression
          if r10
            r0 = r10
          else
            @index = i0
            r0 = nil
          end
        end
      end

      if lrec.active?
        r0 = left_recursion_update(lrec, start_index, r0)
      else
        node_cache[:'Coffee#statement'][start_index] = r0
      end
      break unless lrec.active?
    end
    @stack.pop

    r0
  end

  module Expression0
    def addition
      elements[1]
    end

  end

  module Expression1
    def value
      addition
    end
  end

  module Expression2
    def identifier
      elements[2]
    end

    def expression
      elements[6]
    end
  end

  def _nt_expression
    start_index = index
    if node_cache[:'Coffee#expression'].has_key?(index)
      cached = node_cache[:'Coffee#expression'][index]
      if cached.kind_of? LeftRecursion
        cached.found(@stack.involved_recursions(cached))
        return nil
      end
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end
    lrec = @stack.push(:'Coffee#expression')
    node_cache[:'Coffee#expression'][index] = lrec

    r0 = nil
    loop do
      i0 = index
      i1, s1 = index, []
      s2, i2 = [], index
      loop do
        r3 = _nt_space
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s1 << r2
      if r2
        r4 = _nt_addition
        s1 << r4
        if r4
          s5, i5 = [], index
          loop do
            r6 = _nt_space
            if r6
              s5 << r6
            else
              break
            end
          end
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          s1 << r5
        end
      end
      if s1.last
        r1 = instantiate_node(Expression,input, i1...index, s1)
        r1.extend(Expression0)
        r1.extend(Expression1)
      else
        @index = i1
        r1 = nil
      end
      if r1
        r0 = r1
      else
        i7, s7 = index, []
        i8 = index
        if has_terminal?('λ', false, index)
          r9 = instantiate_node(SyntaxNode,input, index...(index + 2))
          @index += 2
        else
          terminal_parse_failure('λ')
          r9 = nil
        end
        if r9
          r8 = r9
        else
          if has_terminal?('\\', false, index)
            r10 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('\\')
            r10 = nil
          end
          if r10
            r8 = r10
          else
            if has_terminal?('fun', false, index)
              r11 = instantiate_node(SyntaxNode,input, index...(index + 3))
              @index += 3
            else
              terminal_parse_failure('fun')
              r11 = nil
            end
            if r11
              r8 = r11
            else
              @index = i8
              r8 = nil
            end
          end
        end
        s7 << r8
        if r8
          s12, i12 = [], index
          loop do
            r13 = _nt_space
            if r13
              s12 << r13
            else
              break
            end
          end
          if s12.empty?
            @index = i12
            r12 = nil
          else
            r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
          end
          s7 << r12
          if r12
            r14 = _nt_identifier
            s7 << r14
            if r14
              s15, i15 = [], index
              loop do
                r16 = _nt_space
                if r16
                  s15 << r16
                else
                  break
                end
              end
              if s15.empty?
                @index = i15
                r15 = nil
              else
                r15 = instantiate_node(SyntaxNode,input, i15...index, s15)
              end
              s7 << r15
              if r15
                if has_terminal?('->', false, index)
                  r17 = instantiate_node(SyntaxNode,input, index...(index + 2))
                  @index += 2
                else
                  terminal_parse_failure('->')
                  r17 = nil
                end
                s7 << r17
                if r17
                  s18, i18 = [], index
                  loop do
                    r19 = _nt_space
                    if r19
                      s18 << r19
                    else
                      break
                    end
                  end
                  if s18.empty?
                    @index = i18
                    r18 = nil
                  else
                    r18 = instantiate_node(SyntaxNode,input, i18...index, s18)
                  end
                  s7 << r18
                  if r18
                    r20 = _nt_expression
                    s7 << r20
                  end
                end
              end
            end
          end
        end
        if s7.last
          r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
          r7.extend(Expression2)
        else
          @index = i7
          r7 = nil
        end
        if r7
          r0 = r7
        else
          @index = i0
          r0 = nil
        end
      end

      if lrec.active?
        r0 = left_recursion_update(lrec, start_index, r0)
      else
        node_cache[:'Coffee#expression'][start_index] = r0
      end
      break unless lrec.active?
    end
    @stack.pop

    r0
  end

  module Builtins0
    def space
      elements[1]
    end

    def expression
      elements[2]
    end
  end

  module Builtins1
    def expression
      elements[2]
    end

  end

  def _nt_builtins
    start_index = index
    if node_cache[:'Coffee#builtins'].has_key?(index)
      cached = node_cache[:'Coffee#builtins'][index]
      if cached.kind_of? LeftRecursion
        cached.found(@stack.involved_recursions(cached))
        return nil
      end
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end
    lrec = @stack.push(:'Coffee#builtins')
    node_cache[:'Coffee#builtins'][index] = lrec

    r0 = nil
    loop do
      i0 = index
      i1, s1 = index, []
      if has_terminal?('print', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 5))
        @index += 5
      else
        terminal_parse_failure('print')
        r2 = nil
      end
      s1 << r2
      if r2
        r3 = _nt_space
        s1 << r3
        if r3
          r4 = _nt_expression
          s1 << r4
        end
      end
      if s1.last
        r1 = instantiate_node(Print,input, i1...index, s1)
        r1.extend(Builtins0)
      else
        @index = i1
        r1 = nil
      end
      if r1
        r0 = r1
      else
        i5, s5 = index, []
        if has_terminal?('print', false, index)
          r6 = instantiate_node(SyntaxNode,input, index...(index + 5))
          @index += 5
        else
          terminal_parse_failure('print')
          r6 = nil
        end
        s5 << r6
        if r6
          if has_terminal?('(', false, index)
            r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('(')
            r7 = nil
          end
          s5 << r7
          if r7
            r8 = _nt_expression
            s5 << r8
            if r8
              if has_terminal?(')', false, index)
                r9 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure(')')
                r9 = nil
              end
              s5 << r9
            end
          end
        end
        if s5.last
          r5 = instantiate_node(Print,input, i5...index, s5)
          r5.extend(Builtins1)
        else
          @index = i5
          r5 = nil
        end
        if r5
          r0 = r5
        else
          @index = i0
          r0 = nil
        end
      end

      if lrec.active?
        r0 = left_recursion_update(lrec, start_index, r0)
      else
        node_cache[:'Coffee#builtins'][start_index] = r0
      end
      break unless lrec.active?
    end
    @stack.pop

    r0
  end

  module Addition0
    def left
      elements[0]
    end

    def op
      elements[2]
    end

    def right
      elements[4]
    end
  end

  def _nt_addition
    start_index = index
    if node_cache[:'Coffee#addition'].has_key?(index)
      cached = node_cache[:'Coffee#addition'][index]
      if cached.kind_of? LeftRecursion
        cached.found(@stack.involved_recursions(cached))
        return nil
      end
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end
    lrec = @stack.push(:'Coffee#addition')
    node_cache[:'Coffee#addition'][index] = lrec

    r0 = nil
    loop do
      i0 = index
      i1, s1 = index, []
      r2 = _nt_addition
      s1 << r2
      if r2
        s3, i3 = [], index
        loop do
          r4 = _nt_space
          if r4
            s3 << r4
          else
            break
          end
        end
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        s1 << r3
        if r3
          i5 = index
          if has_terminal?('+', false, index)
            r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('+')
            r6 = nil
          end
          if r6
            r5 = r6
          else
            if has_terminal?('-', false, index)
              r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('-')
              r7 = nil
            end
            if r7
              r5 = r7
            else
              @index = i5
              r5 = nil
            end
          end
          s1 << r5
          if r5
            s8, i8 = [], index
            loop do
              r9 = _nt_space
              if r9
                s8 << r9
              else
                break
              end
            end
            r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
            s1 << r8
            if r8
              r10 = _nt_multiplication
              s1 << r10
            end
          end
        end
      end
      if s1.last
        r1 = instantiate_node(BinOp,input, i1...index, s1)
        r1.extend(Addition0)
      else
        @index = i1
        r1 = nil
      end
      if r1
        r0 = r1
      else
        r11 = _nt_multiplication
        if r11
          r0 = r11
        else
          @index = i0
          r0 = nil
        end
      end

      if lrec.active?
        r0 = left_recursion_update(lrec, start_index, r0)
      else
        node_cache[:'Coffee#addition'][start_index] = r0
      end
      break unless lrec.active?
    end
    @stack.pop

    r0
  end

  module Multiplication0
    def left
      elements[0]
    end

    def op
      elements[2]
    end

    def right
      elements[4]
    end
  end

  def _nt_multiplication
    start_index = index
    if node_cache[:'Coffee#multiplication'].has_key?(index)
      cached = node_cache[:'Coffee#multiplication'][index]
      if cached.kind_of? LeftRecursion
        cached.found(@stack.involved_recursions(cached))
        return nil
      end
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end
    lrec = @stack.push(:'Coffee#multiplication')
    node_cache[:'Coffee#multiplication'][index] = lrec

    r0 = nil
    loop do
      i0 = index
      i1, s1 = index, []
      r2 = _nt_multiplication
      s1 << r2
      if r2
        s3, i3 = [], index
        loop do
          r4 = _nt_space
          if r4
            s3 << r4
          else
            break
          end
        end
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        s1 << r3
        if r3
          i5 = index
          if has_terminal?('*', false, index)
            r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('*')
            r6 = nil
          end
          if r6
            r5 = r6
          else
            if has_terminal?('/', false, index)
              r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('/')
              r7 = nil
            end
            if r7
              r5 = r7
            else
              if has_terminal?('%', false, index)
                r8 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure('%')
                r8 = nil
              end
              if r8
                r5 = r8
              else
                @index = i5
                r5 = nil
              end
            end
          end
          s1 << r5
          if r5
            s9, i9 = [], index
            loop do
              r10 = _nt_space
              if r10
                s9 << r10
              else
                break
              end
            end
            r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
            s1 << r9
            if r9
              r11 = _nt_primary
              s1 << r11
            end
          end
        end
      end
      if s1.last
        r1 = instantiate_node(BinOp,input, i1...index, s1)
        r1.extend(Multiplication0)
      else
        @index = i1
        r1 = nil
      end
      if r1
        r0 = r1
      else
        r12 = _nt_primary
        if r12
          r0 = r12
        else
          @index = i0
          r0 = nil
        end
      end

      if lrec.active?
        r0 = left_recursion_update(lrec, start_index, r0)
      else
        node_cache[:'Coffee#multiplication'][start_index] = r0
      end
      break unless lrec.active?
    end
    @stack.pop

    r0
  end

  module Primary0
    def expression
      elements[2]
    end

  end

  module Primary1
    def value
      expression
    end
  end

  module Primary2
  end

  def _nt_primary
    start_index = index
    if node_cache[:'Coffee#primary'].has_key?(index)
      cached = node_cache[:'Coffee#primary'][index]
      if cached.kind_of? LeftRecursion
        cached.found(@stack.involved_recursions(cached))
        return nil
      end
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end
    lrec = @stack.push(:'Coffee#primary')
    node_cache[:'Coffee#primary'][index] = lrec

    r0 = nil
    loop do
      i0 = index
      i1, s1 = index, []
      if has_terminal?('(', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('(')
        r2 = nil
      end
      s1 << r2
      if r2
        s3, i3 = [], index
        loop do
          r4 = _nt_space
          if r4
            s3 << r4
          else
            break
          end
        end
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        s1 << r3
        if r3
          r5 = _nt_expression
          s1 << r5
          if r5
            s6, i6 = [], index
            loop do
              r7 = _nt_space
              if r7
                s6 << r7
              else
                break
              end
            end
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            s1 << r6
            if r6
              if has_terminal?(')', false, index)
                r8 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure(')')
                r8 = nil
              end
              s1 << r8
            end
          end
        end
      end
      if s1.last
        r1 = instantiate_node(Expression,input, i1...index, s1)
        r1.extend(Primary0)
        r1.extend(Primary1)
      else
        @index = i1
        r1 = nil
      end
      if r1
        r0 = r1
      else
        r9 = _nt_number
        if r9
          r0 = r9
        else
          i10, s10 = index, []
          if has_terminal?('\G[a-zA-Z]', true, index)
            r11 = true
            @index += 1
          else
            r11 = nil
          end
          s10 << r11
          if r11
            s12, i12 = [], index
            loop do
              if has_terminal?('\G[\\w]', true, index)
                r13 = true
                @index += 1
              else
                r13 = nil
              end
              if r13
                s12 << r13
              else
                break
              end
            end
            r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
            s10 << r12
          end
          if s10.last
            r10 = instantiate_node(Load,input, i10...index, s10)
            r10.extend(Primary2)
          else
            @index = i10
            r10 = nil
          end
          if r10
            r0 = r10
          else
            @index = i0
            r0 = nil
          end
        end
      end

      if lrec.active?
        r0 = left_recursion_update(lrec, start_index, r0)
      else
        node_cache[:'Coffee#primary'][start_index] = r0
      end
      break unless lrec.active?
    end
    @stack.pop

    r0
  end

  module Number0
  end

  def _nt_number
    start_index = index
    if node_cache[:'Coffee#number'].has_key?(index)
      cached = node_cache[:'Coffee#number'][index]
      if cached.kind_of? LeftRecursion
        cached.found(@stack.involved_recursions(cached))
        return nil
      end
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end
    lrec = @stack.push(:'Coffee#number')
    node_cache[:'Coffee#number'][index] = lrec

    r0 = nil
    loop do
      i0 = index
      s1, i1 = [], index
      loop do
        if has_terminal?('\G[0-9]', true, index)
          r2 = true
          @index += 1
        else
          r2 = nil
        end
        if r2
          s1 << r2
        else
          break
        end
      end
      if s1.empty?
        @index = i1
        r1 = nil
      else
        r1 = instantiate_node(Number,input, i1...index, s1)
      end
      if r1
        r0 = r1
      else
        i3, s3 = index, []
        if has_terminal?('-', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('-')
          r4 = nil
        end
        s3 << r4
        if r4
          s5, i5 = [], index
          loop do
            if has_terminal?('\G[0-9]', true, index)
              r6 = true
              @index += 1
            else
              r6 = nil
            end
            if r6
              s5 << r6
            else
              break
            end
          end
          if s5.empty?
            @index = i5
            r5 = nil
          else
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          end
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(Number,input, i3...index, s3)
          r3.extend(Number0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end

      if lrec.active?
        r0 = left_recursion_update(lrec, start_index, r0)
      else
        node_cache[:'Coffee#number'][start_index] = r0
      end
      break unless lrec.active?
    end
    @stack.pop

    r0
  end

  module Identifier0
  end

  def _nt_identifier
    start_index = index
    if node_cache[:'Coffee#identifier'].has_key?(index)
      cached = node_cache[:'Coffee#identifier'][index]
      if cached.kind_of? LeftRecursion
        cached.found(@stack.involved_recursions(cached))
        return nil
      end
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end
    lrec = @stack.push(:'Coffee#identifier')
    node_cache[:'Coffee#identifier'][index] = lrec

    r0 = nil
    loop do
      i0, s0 = index, []
      if has_terminal?('\G[a-zA-Z]', true, index)
        r1 = true
        @index += 1
      else
        r1 = nil
      end
      s0 << r1
      if r1
        s2, i2 = [], index
        loop do
          if has_terminal?('\G[\\w]', true, index)
            r3 = true
            @index += 1
          else
            r3 = nil
          end
          if r3
            s2 << r3
          else
            break
          end
        end
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Identifier0)
      else
        @index = i0
        r0 = nil
      end

      if lrec.active?
        r0 = left_recursion_update(lrec, start_index, r0)
      else
        node_cache[:'Coffee#identifier'][start_index] = r0
      end
      break unless lrec.active?
    end
    @stack.pop

    r0
  end

  def _nt_space
    start_index = index
    if node_cache[:'Coffee#space'].has_key?(index)
      cached = node_cache[:'Coffee#space'][index]
      if cached.kind_of? LeftRecursion
        cached.found(@stack.involved_recursions(cached))
        return nil
      end
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end
    lrec = @stack.push(:'Coffee#space')
    node_cache[:'Coffee#space'][index] = lrec

    r0 = nil
    loop do
      if has_terminal?('\G[ \\t]', true, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        r0 = nil
      end

      if lrec.active?
        r0 = left_recursion_update(lrec, start_index, r0)
      else
        node_cache[:'Coffee#space'][start_index] = r0
      end
      break unless lrec.active?
    end
    @stack.pop

    r0
  end

  def _nt_newline
    start_index = index
    if node_cache[:'Coffee#newline'].has_key?(index)
      cached = node_cache[:'Coffee#newline'][index]
      if cached.kind_of? LeftRecursion
        cached.found(@stack.involved_recursions(cached))
        return nil
      end
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end
    lrec = @stack.push(:'Coffee#newline')
    node_cache[:'Coffee#newline'][index] = lrec

    r0 = nil
    loop do
      i0 = index
      s1, i1 = [], index
      loop do
        if has_terminal?("\r\n", false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 2))
          @index += 2
        else
          terminal_parse_failure("\r\n")
          r2 = nil
        end
        if r2
          s1 << r2
        else
          break
        end
      end
      if s1.empty?
        @index = i1
        r1 = nil
      else
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      end
      if r1
        r0 = r1
      else
        s3, i3 = [], index
        loop do
          if has_terminal?('\G[\\r\\n]', true, index)
            r4 = true
            @index += 1
          else
            r4 = nil
          end
          if r4
            s3 << r4
          else
            break
          end
        end
        if s3.empty?
          @index = i3
          r3 = nil
        else
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        end
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end

      if lrec.active?
        r0 = left_recursion_update(lrec, start_index, r0)
      else
        node_cache[:'Coffee#newline'][start_index] = r0
      end
      break unless lrec.active?
    end
    @stack.pop

    r0
  end

end

class CoffeeParser < Treetop::Runtime::CompiledParser
  include Coffee
end

